
\section{Approach}
\label{sec:approach}

Before presenting our SQL query inference algorithm, we first describe
the supported SQL language subset.

\newcommand{\q}{\langle query\rangle}
\newcommand{\db}{\langle db\rangle}
\newcommand{\pat}{\langle pat\rangle}
\newcommand{\bug}{\langle bug\rangle}
\newcommand{\dist}{\langle distance\rangle}
\newcommand{\sem}[1]{\llbracket #1\rrbracket}
\newcommand{\lit}[1]{\texttt{#1}}

\newcommand{\column}{\langle column\rangle}
\newcommand{\dbtable}{\langle table\rangle}
\newcommand{\cond}{\langle cond\rangle}
\newcommand{\op}{\langle op\rangle}
\newcommand{\e}{\langle expr\rangle}
\newcommand{\ce}{\langle cexpr\rangle}

\begin{figure}[t]
%\scriptsize{%
\footnotesize%
\begin{align*}
\q ::= {} 
	& \texttt{ SELECT } \e^+ \texttt{ FROM } \dbtable^+ \\
        & \texttt{ WHERE } \cond^+ \\ 
	&  \texttt{ GROUP BY } \column^+ \texttt{ HAVING } \cond^+\\
\dbtable::= {} &\ atom \\
\column ::= {} &\ \dbtable.atom\\
\cond ::= {} &\ \ \cond \;\texttt{\&\&}\; \cond \\ 
    & |\ \cond \;\texttt{||}\; \cond \\
    & |\ \texttt{(}\;\cond\;\texttt{)} \\
    & |\ \ce \;\op\; \ce \\
\op ::= {} &\ \ \texttt{=} \;\;|\;\; \texttt{>}  \;\;|\;\; \texttt{<}\\
\ce ::= {} &\ \ const \;\;|\;\; \column  \;\; \\
\e ::= {} & \ce \\
    & |\ sum(\column) \;\;|\ max(\column) \;\;|\ min(\column) 
\end{align*}
\normalsize%
\caption{Syntax of the supported SQL language subset.}
\label{fig:syntax}
\end{figure}


\subsection{Language}

Figure~\ref{fig:syntax} defines the syntax of the supported, which
is a subset of the standard query language SQL. This language subset
supports common query operations using multiple tables (i.e.,
\CodeIn{select} ... \CodeIn{from}... \CodeIn{where}..), and standard
boolean operators as predicates. The language
subset shares the same semantics with the standard SQL language.
Different than existing work~\cite{DasSarma:2010}, this language supports
joining operations across multiple tables.  In addition, the language includes
widely used database operations such as \CodeIn{group by},
\CodeIn{order by}, and \CodeIn{having}, as
well as a few common aggregation functions such as \CodeIn{sum},
\CodeIn{max}, and \CodeIn{min}.

Compared to the full SQL specification, this language subset is far from complete.
However, there is a tradeoff between the completeness (or expressiveness) of a language,
and the complexity of finding a simple consistent program (here, a SQL query)
within that space defined by the language. In general, the more expressive
a language, the harder the task of effectively finding an answer. When
designing the language subset, we balanced three inter-related principles:

\begin{itemize}

\item \textit{Expressiveness}. The language subset be able
to represent a reasonable set of SQL queries in practice.

\item \textit{Generality}. The language should resemble
the existing SQL language and should not impose additional
or different semantics.

\item \textit{Tool utility}. Inferring a consistent query
using this language subset should be easy to leverage by
domain knowledges and other analyses.

\end{itemize}

As these principles stand in tension, our supported language subset
represents a sweet spot that addressed each of them to a reasonable
extent. As we will show in Section~\ref{sec:evaluation}, this
language subset is expressive enough for most SQL query exercise
after a widely-used textbook and many online forum answers.


\subsection{Inference Algorithm}

We describe an algorithm to infer good SQL queries from the given
input-output examples. Our algorithm consists of three steps:
table alignment (Section~\ref{sec:alignment}),
query completion (Section~\ref{sec:completion}), and
candidate ranking (Section~\ref{sec:ranking}).

\yuyin{can you please wrote the following 3 subsections? I wrote
down a few of my thoughts, which are only for reference. Feel free
to ignore them, and express your own ideas. }

\subsubsection{Table Alignment}
\label{sec:alignment}

Given an input-output example, this step infers a rough form of the
result SQL query. We may define some high-level templates to match
the given examples.

For example, from input-output examples, we can roughly know which
possible constructions (select, join, group by, or ordered by) will
be used. This step can reduce the overall search space.

It the input contains multiple tables, it is unlikely that the inferred
SQL query only selects data from 1 single table, rather, it is more
likely that the intended SQL will utilize all given tables together.

The bound of table number and the bound the conditions.

\subsubsection{Query Completion}
\label{sec:completion}

After getting a rough idea of what the resulting SQL query would
look like, this step completes the remaining uncertain parts by
searching. Smarter search would be preferrable.

How to make a reasonable guess of the remaining parts.

\subsubsection{Candidate Ranking}
\label{sec:ranking}

If a list of multiple SQL queries satisfy the given input-output examples, how
to present the most likely queries to the top?

