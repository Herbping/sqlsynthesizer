\subsection{Query Candidate Ranking}
\label{sec:ranking}

After the first two steps, several SQL queries satisfying the given input-output examples
will be returned. To reduce the effort in selecting a desirable query, we devise a strategy
to rank the most likely query near the top of the list.
%Due to lacking in input-output examples we are not be able to rule out SQL
%queries that lack in generalization ability. Instead we will provide user queries according to a rank.

Here we use a simple but useful strategy based on Occam's razor to rank all inferred SQL query candidates.
For one output query, each table appearing in it introduces a cost $C_t$ and each appearing condition 
results in an additional cost $C_p$. The total number of cost of a query is $n_t*C_t+n_p*C_p$ in which
$n_t$ is the number of tables and $n_p$ is the number of predicates used in the query. The algorithm
ranks the query based on the cost in an increasing order to ensure that a simpler query often ranks higher.

Figure~\ref{fig:rank} shows an example to illustrate this ranking strategy.


\begin{figure}[t]

\begin{tabular}{|l|l|}
%\hline
\multicolumn{2}{l}{Input table: \textbf{student}}\\\hline
%\hline
\textbf{name} & \textbf{score} \\\hline
Bob & 4  \\\hline
Dan & 5  \\\hline
Jim & 2  \\\hline
\end{tabular}
\quad
\begin{tabular}{|l|}
%\hline
\multicolumn{1}{l}{Query output}\\\hline
%\hline
\textbf{name}\\\hline
Bob  \\\hline
Dan  \\\hline
\end{tabular}

\vspace{2mm}


Query 1:
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
\textbf{select name from student where score > 3;}
\end{alltt}
\end{CodeOut}

Query 2:
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
\textbf{select name from student where name = `Bob` or name = `Dan`
}
\end{alltt}
\end{CodeOut}
\vspace{-5mm}
\Caption{{\label{fig:rank} The illustration of our query candidate ranking
strategy. Both Query 1 and Query 2 can transform the example input
to the example output. However, based on our ranking strategy, Query 1
is ranked higher, since it contains less conditions and is simpler
than Query 2.
An inferred query containing more conditions like Query 2 is more likely
to overfit the given examples.}}
\end{figure}
