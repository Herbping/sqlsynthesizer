\subsection{Overview}
\label{sec:algorithm}

\vspace{-1mm}

Figure~\ref{fig:workflow} illustrates \ourtool's workflow.
\ourtool consists of three steps: (1) the ``Skeleton Creation'' step (Section~\ref{sec:skeleton})
creates a set of query skeletons from the given examples;
(2) the ``Query Completion'' step (Section~\ref{sec:completion}) 
infers the missing parts in each query skeleton and outputs
a list of syntactically-valid queries that satisfy
the provided example input and output; and (3) the ``Candidate Ranking'' step (Section~\ref{sec:ranking})
ranks all synthesized SQL queries and places the more likely ones near the top. 
Users can inspect the query list and select an expected query
from it.
If the synthesized SQL queries satisfy the example input and
output, but do not address the user's intention,
\ourtool can be used interactively by requesting more
informative examples from the end-user and then
update the result queries.\todo{xx}

Take the query in Figure~\ref{fig:queryex} as an example,
the ``Skeleton Creation''
step infers its projection columns, query tables, and join conditions; and
the ``Query Completion'' step infers the remaining parts (i.e., aggregates,
query conditions, the \CodeIn{GROUP BY} clause, the
\CodeIn{HAVING} clause, and the \CodeIn{ORDER BY} clause).

Figure~\ref{fig:algorithm} sketches \ourtool's high-level algorithm.
Line 2 corresponds to the first ``Query Skeleton
Creation'' step. Lines 3 -- 13 correspond to the second ``Query Completion''
step, in which \ourtool searches for the query conditions (line 4)\footnote{
Including conditions used in the \CodeIn{HAVIGN} clause.},
aggregates (line 5), and columns in the \CodeIn{ORDER BY} clause (line 6).
\ourtool then assembles a list of candidate SQL queries (line 7), and
validates their correctness on the examples (lines 8 -- 11).
Line 14 corresponds to the ``Query Ranking'' step.

%the result list (line 10). Finally, the query list is sorted by using
%the Occam's razor principle (line 14), and returned to the end-users.

\begin{figure}[t]

\textbf{Input}: example input table(s) $T_I$, example output table $T_O$\\

\vspace{-4mm}
\textbf{Output}: a ranked list of SQL queries\\
\vspace{1mm}
synthesizeSQLQueries({$T_{I}$, $T_{o}$})\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{queryList}$ $\leftarrow$ an empty list\\
\STATE $\mathit{skeletons}$ $\leftarrow$ createQuerySkeletons($\mathit{T_I}$, $\mathit{T_O}$)
\FOR{each $\mathit{skeleton}$ in $\mathit{skeletons}$}
\STATE $\mathit{conds}$ $\leftarrow$ inferConditions($\mathit{T_I}$, $\mathit{T_O}$, $\mathit{skeleton}$)
\STATE $\mathit{aggs}$ $\leftarrow$ searchForAggregates($\mathit{T_I}$, $\mathit{T_O}$, $\mathit{skeleton}$, $conds$)
\STATE $\mathit{columns}$ $\leftarrow$ searchForOrderBys($\mathit{T_O}$, $\mathit{skeleton}$, $\mathit{aggs}$)
\STATE $\mathit{queries}$ $\leftarrow$ buildQueries($\mathit{skeleton}$, $\mathit{conds}$, $\mathit{aggs}$, $\mathit{columns}$)
\FOR{each $\mathit{query}$ in $\mathit{queries}$}
\IF{isValidOnExamples($\mathit{query}$, $\mathit{T_I}$, $\mathit{T_O}$)}
\STATE $\mathit{queryList}$.add($\mathit{query}$)
\ENDIF
\ENDFOR
\ENDFOR
\STATE rankQueries($\mathit{queryList}$)
\RETURN $\mathit{queryList}$
\end{algorithmic}
\vspace{-3mm}
\caption{Algorithm for synthesizing SQL queries from input-output examples.}
 \label{fig:algorithm}
\end{figure}
