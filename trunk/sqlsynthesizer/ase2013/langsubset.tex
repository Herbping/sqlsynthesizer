\newcommand{\q}{\langle query\rangle}
\newcommand{\db}{\langle db\rangle}
\newcommand{\pat}{\langle pat\rangle}
\newcommand{\bug}{\langle bug\rangle}
\newcommand{\dist}{\langle distance\rangle}
\newcommand{\sem}[1]{\llbracket #1\rrbracket}
\newcommand{\lit}[1]{\texttt{#1}}

\newcommand{\column}{\langle column\rangle}
\newcommand{\dbtable}{\langle table\rangle}
\newcommand{\cond}{\langle cond\rangle}
\newcommand{\op}{\langle op\rangle}
\newcommand{\e}{\langle expr\rangle}
\newcommand{\ce}{\langle cexpr\rangle}

\begin{figure}[t]
%\scriptsize{%
\footnotesize%
\begin{align*}
\q ::= {} 
	& \texttt{ SELECT } \e^+ \texttt{ FROM } \dbtable^+ \\
        & \texttt{ WHERE } \cond^+ \\ 
	&  \texttt{ GROUP BY } \column^+ \texttt{ HAVING } \cond^+\\
	&  \texttt{ ORDER BY } \column^+ \\
\dbtable::= {} &\ atom \\
\column ::= {} &\ \dbtable.atom\\
\cond ::= {} &\ \ \cond \;\texttt{\&\&}\; \cond \\ 
    & |\ \cond \;\texttt{||}\; \cond \\
    & |\ \texttt{(}\;\cond\;\texttt{)} \\
    & |\ \ce \;\op\; \ce \\
    & |\ \texttt{NOT EXIST} \;(\q) \\
\op ::= {} &\ \ \texttt{=} \;\;|\;\; \texttt{>}  \;\;|\;\; \texttt{<}\\
\ce ::= {} &\ \ const \;\;|\;\; \column  \;\; \\
\e ::= {} & \ce \;\;|\ count(\column) \\
    & |\ sum(\column) \;\;|\ max(\column) \;\;|\ min(\column) 
\end{align*}
\normalsize%
\caption{Syntax of the supported SQL subset.}
\label{fig:syntax}
\end{figure}


\section{Supported SQL Subset}
\label{sec:langsubset}

This section presents the design of
a supported SQL subset in \ourtool.

\subsection{Eliciting Design Requirements}

\todo{Explain why a survey is needed (the langauge is
too big). It will become intractable. And how}

Took a different way than existing work in eliciting
design requirement.


\subsection{Syntax}


Figure~\ref{fig:syntax} defines the syntax of the supported language,
which is a subset of the standard SQL 93 language. This SQL subset
supports common query operations across multiple tables (i.e.,
\CodeIn{select} ... \CodeIn{from} ... \CodeIn{where}..), and 
conjunction of predicates. The language
subset shares the same semantics with the standard SQL language.

\todo{some design rationale}
1. discard some vendor-specific grammars, like top in Microsoft,

2 discard fuzzy matching part for example, like " ... ", wildcards,
makes undecidable, can use string manipulation.

3. exclude delete, update query statement, because we focus on query

4. Omit distinct, in (which can be replaced by NOT EXIST, or condition query)

5. omit between, discard Left Joint, Right Join, only remaining Full Join

6. Not Null (can be simply replaced by != NULL)

7. Nested query can always be re-written using conditions


\todo{revise the following}
Differing from language subsets used in the
existing work~\cite{DasSarma:2010}, our language subset
supporting
joining operations across multiple tables, and includes
widely-used database operations such as \CodeIn{group by},
\CodeIn{order by}, and \CodeIn{having}, as
well as a few common aggregation functions such as \CodeIn{count}, \CodeIn{sum},
\CodeIn{max}, and \CodeIn{min}.

%\todo{remove}
%As we will show in Section~\ref{sec:evaluation}, this
%subset, though far from completion, is expressive enough for answering
%many evaluated SQL exercises from a textbook and some real problems
%from online forums.

\subsection{Feedback about the SQL Subset}

Send another survey to confirm our design.

