
\section{Related Work}
\label{sec:related}

\vspace{-1mm}

%\enlargethispage{5pt}

We next discuss two categories
of related work on reverse engineering SQL queries 
and automated program synthesis.


%\subsection{Reverse Engineering SQL Queries}

%\vspace{1mm}
\noindent{\textbf{\textit{Reverse Engineering SQL Queries.}}}
Reverse engineering SQL queries is a technique~\cite{Zloof:1975, Tran:2009, DasSarma:2010} to
improve a database's usability. 
Zloof's work on \textit{Query by Example} (QBE)~\cite{Zloof:1975}
provided a high-level query language and a
form-based Graphical User Interface (GUI) for
writing database queries. To use the QBE system, 
users need to learn its query language,
formulate a query with the language, and fill in
the appropriate skeleton tables on the GUI.
By contrast, \ourtool mitigates such learning curves
by only requiring users to provide some representative
examples to describe their intentions

  %In other words, to derive a SQL query with the QBE system,
%end-users must learn a new query formulation language
%and explore its GUIs. These are the exactly
%two activities that may increase end-users' learning curve, and are avoided
%in \ourtool. \todo{exactly what we need to avoid.}



Tran et al.~\cite{Tran:2009} proposed a technique,
called \textit{Query by Output} (QBO), to infer SQL queries from examples.
As we have discussed thoroughly in Section~\ref{sec:comparison},
QBO excludes many useful SQL features and can only
infer simple select-project-join queries.
Our experiments demonstrated that QBO failed
to infer queries for many use-case scenarios.

Recently, Sarma et al.~\cite{DasSarma:2010} studied the \textit{View Definitions Problem} (VDP).
VDP aims to find the most
succinct and accurate view definition, when
the view query is restricted to a specific family of queries.
VDP can be solved as a special case in \ourtool where there is only one
input table and one output table. Furthermore, the main contribution
of Sarma et al's work is the complexity analysis of
three variants of the view definitions problem; there is no
tool implementation or empirical studies to evaluate
the proposed technique.

%Compared to \ourtool, there are three key differences:
%(1) VDP aims to infer a relation from a large representative
%example view, while \ourtool attempts to infer a SQL query from a
%set of few input-output examples \todo{revise below}
%(which is a critical usability aspect for end-users who lack adequate
%SQL experience). (2) the technique proposed by Sarma et al.~\cite{DasSarma:2010} does
%not consider join or projection
%operations and assumes the output view to be a strict subset of the input
%database with the same schema\todo{revise}, while our work eliminates these
%assumptions, and considers both join and projection operations.\todo{revise above}



%\todo{what is the limitation of non program sythesis, why
%sythensis would be useful.}

%\subsection{Automated Program Synthesis }

%\vspace{1mm}

\noindent{\textbf{\textit{Automated Program Synthesis.}}}
Program synthesis~\cite{Gulwani:2010:DPS} is a useful
technique to create an executable program
in some underlying language from specifications that can range
from logical declarative specifications to examples or
demonstrations~\cite{Harris:2011, singh:2012, Gulwani:2011,
Kandel:2011, Fisher08Pads,Lau:2003:PDU, Lau:2000:VSA, Barbosa:2010:MLA, Arasu:2009:LST}.
It has been used recently for many applications.
%such as synthesis of efficient low-level code~\cite{Solar-Lezama:2005},
%data structure manipulations~\cite{Fisher:2008},
%geometry constructions~\cite{Gulwani:2011:SGC},
%snippets of excel macros~\cite{Harris:2011},
%relational data representations~\cite{Barbosa:2010:MLA, Arasu:2009:LST} and string
%expressions~\cite{singh:2012, Gulwani:2011}.


The PADS~\cite{Fisher:2008} system takes a large sample
of unstructured data and infers a
format that describes the data. Related,
the Wrangler tool, developed in the HCI community,
provides a visual interface for table transformation
and data cleaning~\cite{Kandel:2011}.
These two techniques, though well-suited for tasks
like text extraction, cannot be used to 
synthesize a database query.
This is because text extraction tasks
use completely different abstractions than a database query task;
and the existing tools like PADS and Wrangler lack the support for many database operations
such as joins and aggregation.

%text extraction tasks
%use completely different abstractions than a database query. and lack the support
%for many database operations like table joining, aggregations, etc.

%For example, while text extraction and mass editing
%are quite valuable for data transformation, the above tools
%lack other needed operations such as table joinning,
%aggregation, and query condition inference.
%\todo{explain}


Harris and Gulwani described a system for learning excel
spreadsheet transformation macros from an example
input-output pair~\cite{Harris:2011}. Given one input table and one output
table, their system can infer an excel macro that filters,
duplicates, and/or re-organizes table cells to generate the output table.
\ourtool differs in multiple respects.
First, excel macros have significantly different
semantics than SQL queries.
An excel macro can express a variety of table transformation operations
(e.g., table re-shaping), but are not capable to formulate database queries.
Second, Harris and Gulwani's approach treats table cells
as atomic units, and thus has different expressiveness
than \ourtool. For instance, their technique can generate macros to
transform one table to another, but cannot join multiple
tables or aggregate query results by certain table columns. 
In fact, none of the textbook exercises or forum questions
in Figure~\ref{tab:results} can be solved by
Harris and Gulwani's technique~\cite{Harris:2011}.
%does not support queries
%involving conditions table joining, aggregation, or even column projection.
%\todo{examples}


%By contrast, \ourtool provides
%an interface based on examples, which is more
%friendly to end users. \todo{However, }


Some recent work proposed query recommendations systems
to enhance a database's usability~\cite{Howe:2011, Khoussainova:2010}. 
SQLShare~\cite{Howe:2011} is a web service that allows
users to upload their data and SQL queries,
%Each uploaded query is saved as a view, 
permitting other users
to compose and reuse. SnipSuggest~\cite{Khoussainova:2010} is a SQL autocompletion
system. As a user types a query, SnipSuggest mines existing query
logs to recommend relevant clauses or SQL snippets (e.g., the table
names for the \CodeIn{FROM} clause) based on the partial query that
the user has typed so far.
Compared to \ourtool, both SQLShare and SnipSuggest assume the
existence of a comprehensive query log
that contains valuable information.
%as a user articulates an increasingly larger fragment of a query.
However, such assumption often does not hold for
many database end-users in practice.
\ourtool eliminates this assumption and infers 
SQL queries using user-provided examples.


Cheung et al.~\cite{abs-1208-2013} presented a technique to infer SQL
queries from imperative code. Their technique transforms
fragments of application logic (written in an imperative language
like Java) into SQL queries. 
Compared to \ourtool, their work aims to help developers
improve a database application's performance,
rather than helping non-expert end-users
write correct SQL queries from scratch. 
If an end-user wishes to use their technique to 
synthesize a SQL query, she must write a snippet of
imperative code to describe the query task.
Comparing to providing examples,
writing correct imperative code is too challenging
for a typical end-user, and thus would
inevitably degrade the technique's usability.


%also cite this~\cite{Cheung:2012:UPS}, combining machine learning with program synthesis.
