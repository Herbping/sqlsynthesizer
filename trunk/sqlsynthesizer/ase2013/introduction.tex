\section{Introduction}
\label{sec:introduction}


The big data revolution over the past few years has resulted
in significant advances in digitization of massive amounts
of data and accessibility of computational devices to massive
proportions of the population. A key challenge faced by many
enterprise or computer end-users nowadays is the management
of their increasingly large and complex databases.
%, which can contain
%hundreds and even thousands of tables. 


%but they often need to
%query databases to obtain relevant data to support their business decisions.


\subsection{End-users' Difficulties in Writing SQL Queries}
Although the relational database management system (RDBMS) and the
de facto language (SQL) are perfectly adequate for most end-users'
needs~\cite{Howe:2011}, the costs associated with deployment and
use of database software and SQL are prohibitive. 

The problem is exacerbated by the fact that many end-users
have myriad diverse backgrounds including research scientists,
business analysts, commodity traders, human resource managers,
finance professionals, and marketing managers. 
Those end-users who need to query databases to analyze the
data are not professional programmers, but are experts in some
other domains. They need to query a variety of information on their
database and use the information to support their business decisions.
\todo{move the following sentence to somewhere esle}
For example, as pointed out
by~\cite{Gray:2005}, conventional RDBMS software remains underused
in the long tail of science: the large number of users, such as the
research scientists who are in relatively small labs and individual
researchers, have limited IT training, staff and infrastructure yet
collectively produce the bulk of scientific knowledge. 

%Similarly, other end-users
%such as business analysts who query databases frequently often
%do not have significant SQL expertise.

Most non-professional database end-users often learn
SQL queries by first \todo{x} consulting a textbook or browsing some
online resources to get familiar basic idioms of SQL.
Then, they may try to write some experimental SQL queries, execute them
on a sample database to explore the data, and subsequently \todo{xx} modify
the queries to write new queries based on the query results.
%predicates in the \CodeIn{where} clause,
%tables in the \CodeIn{from} clause, or columns in the \CodeIn{select} clauses.
However, such practice is inefficient and time-consuming.
\todo{explain why}.
Those end-users can clearly understand
their goals but simply can not write a correct SQL query for
their tasks, either due to the syntax complexity of the language itself,
or the structure complexity of the underlying databases, or others.
To assist them in performing database query tasks,
%For them, they need an \textit{intelligent} tool
%to assist them to perform database query tasks. 
a highly accessible tool that can be used to ``describe''
their needs and connect their intentions to executable
SQL queries would be highly desirable.


\subsection{Existing Solutions}


\textit{Graphical User Interfaces} (GUIs) and \textit{general programming languages}
are two state-of-the-art approaches in helping end-users perform
database queries. However, both of them are far from satisfactory.

Many RDBMS come with a well-designed GUI with tons of features.
However, 
%as a database management system often comes with tons
%of features, end-users struggle to find the correct feature or
%succession of commands to use from a maze of features to accomplish
%their tasks.
a GUI is often fixed, and does not permit users to personalize
a database's functionality for their specific tasks. On the other hand,
as a GUI supports more and more customization features, users
may struggle to discover those features, which can significantly
degrade its usability. 

General programming languages, such as SQL,
Java (with JDBC), or other domain specific query languages, \todo{add non-SQL}
serve as a fully expressive medium  for
communicating a user's intention to a database. However, learning
a practical programming language (even a simplified, high-level domain
specific language) often requires a substantial amount
of time and energy that a typical end-user would not prefer,
and should not be expected, to invest. 



\subsection{Synthesizing SQL Queries from Input-Output Examples}

%After carefully studying how end-users were describing their
%encountered SQL query problems on online help forums, we observed that
%one of the most common ways for end-users to
%express their intents is using input-output examples. 

In this paper, we present a technique (and its tool
implementation, called \ourtool) to automatically synthesize SQL queries
from input-output examples. \ourtool takes example input
table(s) and output table from the end-users, and then automatically
infers a SQL query (or multiple queries, if exist) that queries
against the input tables and returns the output example. If the inferred
SQL query is applied
to the example input, then it produces the example output; and if the
SQL query is applied to other similar inputs (potentially much larger tables),
then the SQL query produces a corresponding output.

\todo{explain why input-output examples is well-suited?}
Although
input-output examples may lead to underspecification, they
serve as a straightforward way of describing \textit{what} the
task is and a natural interface that a tool can provide assistance.

Our technique is designed to be used by non-professional \todo{beginner}
database end-users when they do not know how to write a desirable SQL query.
It aims to replace the role of the forum expert, \todo{also trainers?}
which not only removes human from the loop, but also enables
end-users to solve their problems in a few seconds as opposed to a few days
(while waiting for an expert's reply). 
\todo{right place?}
We also envision this technique to be useful in an online education
setting. Recently, several education initiatives such as EdX, Coursera,
and Udacity are teaming up with experts to provide high quality online courses
to several thousands of students worldwide.
One challenge, which is not present in a traditional classroom
setting, is to provide answers on questions raised by a large
number of students.
\todo{explain why SQLSynthesier is useful.}

%on practice exercises and assignments to a large number of students. 




\ourtool uses three steps to link a user's intention to
a desirable SQL query:


\todo{add to somewhere}
helping end-users writing a wide range of SQL queries.

\begin{itemize}
\item XXX
\item XXX
\item XXX
\end{itemize}

Compared to previous approaches~\cite{}, \ourtool has several
notable features:

\begin{itemize}
\item XXX
\item XXX
\end{itemize}


%is usually the correct one. 

%Besides
%selecting a smaller one, we could also compute the likelihood
%of each query being correct based on some statistics, and then
%pick the most likely one.


\subsection{Evaluation}

We evaluated \ourtool on \exnum 
exercises from a classic database textbook~\cite{cowbook}. 
SQL exercises
from a database textbook often cover
the most widely-used SQL features 
that a course instructor wishes students to master.
\todo{expressiveness}
Those exercises can be served as golden test
to evaluate the expressiveness of our supported SQL subset. 
Second,
we collected 5 non-trivial SQL problems raised by real end-users on online
help forums, and tested whether our technique can effectively synthesize desirable
SQL queries.  

As a result, our technique successfully synthesized 5 out of 6
textbook exercises and solved all 5 forum problems, within a very
small amount of time (1 minute per exercise/problem, on average).

\subsection{Contributions}

This paper makes the following contributions:

\begin{itemize}
%\item \textbf{Problem.} To the best of our knowledge, we are the first
%to address the SQL query synthesis problem from examples across multiple
%tables.
%An approach to automatically synthesizing SQL
%queries from input-output examples (Section~\ref{sec:approach}).

\item \textbf{Technique.} We present a technique automatically
synthesize SQL queries from input-output examples
(Section~\ref{sec:approach}).

\item \textbf{Implementation.} We implemented our technique in a
tool, called \ourtool (Section~\ref{sec:implementation}). It is
available at: \url{http://sqlsynthesizer.googlecode.com}.

\item \textbf{Evaluation.} We applied \ourtool
to \exnum textbook SQL exercises and \pnum 
SQL-related problems from online forums.
The results show the usefulness of the proposed technique
(Section~\ref{sec:evaluation}).
\end{itemize}
