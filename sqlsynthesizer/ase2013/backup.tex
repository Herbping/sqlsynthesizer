When searching information, a first and
crucial step is queries formulations. However


Our technique follows a general methodology for designing
systems supporting programming by examples~\cite{Harris:2011}.
It includes the following three major steps:
(1) identify a language subset (of SQL) that is expressive to
describe a large proportion of %operations that users need to perform
database queries; (2) design an algorithm that
can efficiently infer programs in the language from input-output
examples; and (3) develop a ranking strategy that presents
the most likely program to the users, when multiple solutions exist.

\vspace{1mm}
\noindent \textbf{\textit{Supported SQL Subset.}}
The full SQL 93 specification contains over 1000 pages, and it is
infeasible and unnecessary to support all language features in practice.
When selecting a supported SQL subset, there is a tradeoff
between the expressiveness of the selected language subset,
and the complexity of finding simple consistent solutions
within that language's search space.  In general, the more expressive a search
space, the harder the task of finding consistent hypotheses within
that search space. 

During our study of end-user's real problems, we also carefully studied what would
be the solution to users' desired query, and found that the most common
desired queries can be composed by a handful of basic SQL constructs,
which form the target language of this work (Section~\ref{sec:langsubset}).

As shown in our experiments (Section~\ref{sec:evaluation}), the supported subset, though far from completion, is expressive
enough to describe many query tasks succinctly, while at the same time concise
enough to be amenable for efficient inference. 



\vspace{1mm}
\noindent \textbf{\textit{SQL Query Inference Algorithm.}} Our inference
algorithm, as described in Section~\ref{sec:approach}, consists of two
major steps. The first step, called \textit{SQL Skeleton Creation}, scans
the example input and output, and \textit{guesses} what a desirable
SQL query may look like. The output of this step is a set of \textit{incomplete} SQL
query skeletons. A SQL query skeleton is an incomplete SQL query,
which contains unknown parts. The second step,
called \textit{SQL Query Completion} takes as inputs a created
SQL skeleton, fills unknown parts with possible solutions, and then produces a set of
syntactically-valid SQL queries. In particular, when performing
SQL query completion, our technique uses a rule learning algorithm
to infer the conditions (Section~\ref{sec:decision_tree}), and uses 
type-directed search to infer possible aggregates in a query (Section~\ref{sec:agg_search}).

\vspace{1mm}
\noindent \textbf{\textit{Query Candidate Ranking Strategy.}}
Input-output examples provided by end-users are likely to
be under-specified. It is entirely possible that multiple
queries can be synthesized to satisfy the provided examples.
We address this problem by developing a ranking scheme that 
ranks the possibly multiple queries
consistent with the given input-output
examples. Our ranking scheme, detailed in Section~\ref{sec:ranking}
is inspired by the Occam's razor principle, prefers a smaller and
simpler solution if other aspects being equal.



Figure~\ref{fig:workflow} sketches the general workflow of our technique.
At a high level, our technique consists of three major steps: Query Skeleton
Creation(Section~\ref{sec:skeleton}), SQL Query Completion
(Section~\ref{sec:completion}), and Query Candidate Ranking (Section~\ref{sec:ranking}).
Specifically, our approach takes from users input-output examples. It first infers
a partially-complete query skeleton. The inferred query skeleton, though contains
incomplete parts that can not be yet decided, serves as a good reference
for further synthesizing a complete SQL query.
After that, our technique uses two techniques to complete a SQL skeleton.
In particular, it uses an advanced rule learning algorithm from the machine
learning community to infer query conditions (Section~\ref{sec:decision_tree}), and
 employs type-directed search to figure out possible aggregation
expressions (Section~\ref{sec:agg_search}).
The SQL Query Completion step produces a list of syntactically-valid
query candidates that satisfy the provided input-output examples.
However, it is possible that multiple query candidates can be synthesized based on the
provided input-output example. To deal with that, our technique

%This makes our tool more usable.


\begin{figure}[t]
	\centering
\begin{tabular}{|c|c|c|}
\hline
 Student\_key& Student\_name & Level\\
\hline
 0001 & Adam & senior \\
 \hline
 0002 & Bob & junior \\
 \hline
 0003 & Erin & senior \\
 \hline
 0004 & Rob & junior\\
 \hline
 0005 & Dan & senior \\
 \hline
 0006 & Peter & senior \\
 \hline
 0007 & Sai & senior \\
 \hline
\end{tabular}
	\caption{An example input table `student'
for the SQL question described in
Section~\ref{sec:example}.}
	\label{tbl:student}
\end{figure}


\begin{figure}[t]
	\centering
\begin{tabular}{|c|c|c|}
\hline
 Student\_key& Course\_key& Score \\
\hline
 0001 & 001 & 4 \\
\hline
 0001 & 002 & 2 \\
\hline
 0002 & 001 & 3 \\
\hline
 0002 & 002 & 2 \\
\hline
 0002 & 003 & 3 \\
\hline
 0003 & 002 & 1 \\
\hline
 0004 & 001 & 4 \\
\hline
 0004 & 003 & 4 \\
\hline
 0005 & 002 & 5 \\
\hline
 0005 & 003 & 2 \\
\hline
 0005 & 004 & 1 \\
\hline
 0006 & 002 & 4 \\
\hline
 0006 & 004 & 5 \\
\hline
 0007 & 001 & 2 \\
\hline
 0007 & 003 & 3 \\
\hline
 0007 & 004 & 4 \\
 \hline
\end{tabular}
	\caption{An example input table  `enrolled'
for the SQL question described in
Section~\ref{sec:example}.}
	\label{tbl:enrolled}
\end{figure}	

\begin{figure}[t]
	\centering
\begin{tabular}{|c|c|}
\hline
 Student\_name & Max\_score \\
\hline
 Dan & 5 \\
\hline
 Sai & 5 \\
 \hline
\end{tabular}
	\caption{An example output table for the SQL question described in
Section~\ref{sec:example}.}
	\label{tbl:output}
\vspace{3mm}
\end{figure}		


\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
\textbf{select student.Student\_name, max(enrolled.Score)
from student, enrolled
where student.Student\_key = enrolled.Student\_key
      and student.Level = `senior'
group by student.Student\_key
having count(enrolled.Course\_key) > 3}
\end{alltt}
\end{CodeOut}
\vspace{-5mm}
	\caption{A SQL query to solve the SQL question described in
Section~\ref{sec:example}. When applied to the input tables in
Figure~\ref{tbl:student} and Figure~\ref{tbl:enrolled}, it produces the result table
in Figure~\ref{tbl:output}.}
	\label{fig:expected_sql}
\end{figure}

\begin{figure}[t]
\centering
\textbf{The input Table1:}

\begin{tabular}{|c|c|c|c|}
\hline
 Column1 & Column2& Column3& Column4\\
 \hline
 101 &  2001 &  3020 &  01-01-11\\
\hline
 101 &  2001 &  3002 &  02-01-11\\
\hline
 101 &  2001 &  3001 &  03-01-11\\
\hline
 102 &  2002 &  3002 &  01-01-11\\
\hline
\end{tabular}

\vspace{2mm}

\textbf{The input Table2:}

\begin{tabular}{|c|c|c|}
\hline
 Column1 & Column2& Column3 \\
 \hline
 20011 &  2001 &  200131\\
\hline
 20012 &  2001 &  200132\\
\hline
 20013 &  2001 &  200133\\
\hline
\end{tabular}

\vspace{2mm}

\textbf{The input Table3:}

\begin{tabular}{|c|c|}
\hline
 Column1 & Column2\\
 \hline
 20011 &  Site\\
\hline
 20012 &  Site\\
\hline
 20013 &  Site\\
\hline
\end{tabular}

\vspace{3mm}

\textbf{The output table:}

\begin{tabular}{|c|c|c|c|}
\hline
 101 & 200131 & 01-01-11 & Site\\
 \hline
 101 & 200132 & 01-01-11 & Site\\
 \hline
 101 & 200133 & 01-01-11 & Site\\
 \hline
\end{tabular}
\Caption{{\label{fig:example} Input-output examples taken from
an online SQL help forum thread. Our technique 
automatically synthesizes a SQL query as shown in Figure~\ref{fig:answer}
that produces the output table from the three input tables.
}} \vspace{2mm}
\end{figure}

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
\textbf{select min(T1.Column1), T2.Column3,
       min(T1.Column4), min(T3.Column2)
from Table1 T1, Table2 T2, Table3 T3
where T1.Column2 = T2.Column2 and T2.Column1 = T3.Column1
group by T2.Column3}
\end{alltt}
\end{CodeOut}
\vspace{-5mm}
\Caption{{\label{fig:answer} The highest ranked SQL query inferred
by our technique from the input-output examples in Figure~\ref{fig:example}.}}
\end{figure}


Techniques to efficiently find rules from data has been studied extensively
by many machine learning researchers~\cite{Quinlan:1993, Cohen:1995, Frank:1998}.
Generally, in the machine learning community, there are major two paradigms of
rule learning:

%\begin{itemize}
%\item
\vspace{1mm}
\noindent\textbf{\textit{1. Decision-tree learning~\cite{Quinlan:1993}}}. Given
the positive and negative examples, one can generate a decision
tree, and then extract decision-tree-splitting conditions from the root to
all positive leaf. The extracted conditions can be viewed as the selection
criteria that isolates the output data from the input searching space.


%\item
\vspace{1mm}
\noindent\textbf{\textit{2.``Divide-and-conquer'' strategy~\cite{Pagallo:1990}}}. 
Unlike decision-tree learning, instead of learning a full tree,
this methodology repeatedly determines the most powerful rules for the dataset
that can maximally separate the positive examples from the negative ones, until
no more positive examples are available.

\vspace{1mm}

However, for our problem, both methodologies can not be directly applied.
Learning rules via decision-tree learning is restricted to conjunctive rules,
which is insufficient for many real scenarios. On the
other hand, the generalization ability of the ``divide-and-conquer'' strategy
is quite limited due to overpruning and covering heuristic.
\todo{The above paragraphs are not clear.}
