\section{Introduction}
\label{sec:introduction}


The big data revolution over the past few years has resulted
in significant advances in digitization of massive amounts
of data and accessibility of computational devices to massive
proportions of the population. There is a growing population
of non-expert database end-users, who need to perform
analysis on their databases, but have limited programming knowledge.

%A key challenge faced by many
%enterprise and computer end-users nowadays is the management
%of their increasingly large and complex databases.
%, which can contain
%hundreds and even thousands of tables. 


%but they often need to
%query databases to obtain relevant data to support their business decisions.


%\subsection{End-users' Difficulties in Writing SQL Queries}
%\vspace{1mm}
%\noindent \textbf{\textit{Motivation.}}
Although the relational database management system (RDBMS) and the
de facto query language (SQL) are perfectly adequate for most end-users'
needs, 
the costs associated with use of database and SQL are non-trivial~\cite{Howe:2011}. 
The problem is exacerbated by the fact that many end-users
have myriad diverse backgrounds and include
business analysts, commodity traders, human resource managers,
finance professionals, and marketing managers. 
Those end-users are not professional programmers, but are experts in some
other domains. They need to retrieve a variety of information from their
databases and use the information to support their business decisions.
Although most end-users can clearly describe \textit{what} the task is, they
are often stuck with the process of \textit{how} to
write a correct database query (i.e., a SQL query).
% even after
%receiving step-by-step, detailed,
%and syntactically correct instructions.
Thus, non-expert end-users often need to
seek information from online help forums, or ask
SQL experts. This process can be repetitive, laborious, and frustrating.
To assist non-expert end-users in performing database query tasks,
%For them, they need an \textit{intelligent} tool
%to assist them to perform database query tasks. 
a highly accessible tool that can be used to ``describe''
their needs and ``connect'' their intentions to executable
SQL queries would be valuable. %highly desirable.

%simply can not get the SQL query correct,
%either due to the syntax complexity of the SQL language itself,
%or the structure complexity of the databases.
%To write a correct SQL query, end-users often need to
%seek information from online help forums, or ask
%SQL experts. This process can be repetative, laborious, and frustrating.

%However, such practice is inefficient and time-consuming.
%Non-professional end-users 


%\todo{move the following sentence to somewhere esle}

%Similarly, other end-users
%such as business analysts who query databases frequently often
%do not have significant SQL expertise.

%To learn how to query a RDBMS, most end-users often refer
%to a textbook or online resources to first get familiar with
%the basic idioms of the SQL language. Then, they may
%try to write some experimental queries, execute them
%on a sample database to observe the output, and
%subsequently revise the queries (if the output is not desirable).

%The above process may
%predicates in the \CodeIn{where} clause,
%tables in the \CodeIn{from} clause, or columns in the \CodeIn{select} clauses.



%\subsection{Existing Solutions}

\vspace{1mm}
\noindent \textbf{\textit{Existing solutions.}}
\textit{Graphical User Interfaces} (GUIs) and \textit{programming languages}
are two state-of-the-art approaches to help end-users perform
database queries. However, both approaches are far from satisfactory.

Many RDBMS come with a well-designed GUI with lots of features.
However, 
%as a database management system often comes with tons
%of features, end-users struggle to find the correct feature or
%succession of commands to use from a maze of features to accomplish
%their tasks.
a GUI is often fixed, and does not permit users to personalize
a database's functionality for their query tasks. On the other hand,
as a GUI supports more and more customization features, users
may struggle to discover those features, which can significantly
degrade its usability. 

Programming languages, such as SQL,
Java (with JDBC), or other domain specific query languages, 
serve as a fully expressive medium  for
communicating a user's intention to a database. However, 
general programming languages have never been easy for
end-users who are not professional programmers.  Learning
a practical programming language (even a simplified domain
specific language, such as MDX~\cite{mdx}) often requires a substantial amount
of time and energy that a typical end-user would not prefer,
and should not be expected, to invest. 



%\subsection{Synthesizing SQL Queries from Input-Output Examples}

%After carefully studying how end-users were describing their
%encountered SQL query problems on online help forums, we observed that
%one of the most common ways for end-users to
%express their intents is using input-output examples. 

\vspace{1mm}
\noindent \textbf{\textit{Our solution: synthesizing SQL queries from input-output examples}}
In this paper, we present a technique (and its tool
implementation, called \ourtool) to automatically
synthesize SQL queries
\footnote{
All queries mentioned in this paper refer to SQL queries
that retrieve data from a database but
do not update its content.}
from input-output examples.
Although input-output examples may lead to
underspecification, writing them, as opposed to writing
declarative specifications or imperative code
of any form, is one of the easiest ways
for end-users to describe \textit{what} the task is.
%\ourtool takes example input
%table(s) and output table from the end-users, and then automatically
%infers a SQL query (or multiple queries, if exist) that queries
%against the input tables and returns the output example.
If the synthesized SQL query is applied
to the example input, then it produces the example output; and if the
synthesized SQL query is applied to other
similar input (potentially much larger tables),
then it produces a corresponding output.


%\ourtool uses such input-output examples
%as a natural interface to "understand" an end-user's intention
%and provide corresponding assistance.

%Compared with other alternatives (such as, writting
%a declarative specification) to specify a user's intention,
%input-output examples, although may lead to underspecification,
%serve as a more straightforward way  is and a natural interface that a tool can provide assistance.

\ourtool is designed to be used by non-expert database
end-users when they do not know how
to write a correct SQL query. 
End-users can use \ourtool to obtain a SQL query to transform
multiple, huge database tables by constructing small, representative
input and output example tables. 
We also envision \ourtool to be useful in an online education
setting (i.e., an online database course). Recently, several
education initiatives such as EdX~\cite{edx}, Coursera~\cite{coursera},
and Udacity~\cite{udacity} are teaming up with experts to provide
high quality online courses
to several thousands of students worldwide.
One challenge, which is not present in a traditional classroom
setting, is to provide answers to questions raised by a large
number of students. A tool, like \ourtool,
that has the potential of answering SQL query related questions
would be useful.
%preferrable in \todo{teaching a database course.}
%helping end-users writing a wide range of SQL queries.


Inferring SQL queries from examples is challenging,
primarily for two reasons. First, the standard SQL
language is inherently complex; a SQL query can consist
of many parts, such as joins, aggregates,
the \CodeIn{GROUP BY} clause, and the \CodeIn{ORDER BY} clause.
Searching for a SQL query
to satisfy a given example input and output pair,
as proved by Sarma et al.~\cite{DasSarma:2010},
is a PSPACE-hard problem. Thus,
a brute-force approach such as exhaustively
enumerating all
syntactically-valid SQL queries and then
filtering away those do not satisfy the examples
becomes intractable in practice. 
Second, a SQL query has a rich set of operations: it
needs to be evaluated on \textit{multiple} input tables;
it needs to perform data grouping, selection, and ordering
operations; and it needs to project data on certain columns to
form the output.
All such operations must be inferred properly and efficiently.% This requires \todo{new challenges}
%unlike a spreadsheet macro  that
%re-shapes one input table to one output table~\cite{Harris:2011},


To address these challenges and make example-based
SQL query synthesis feasible in practice,
\ourtool focuses on a widely-used SQL subset (Section~\ref{sec:langsubset}),
and uses three steps to link a user's intention to
a SQL query (Section~\ref{sec:approach}):



\begin{itemize}
\item \textbf{Skeleton Creation.} \ourtool scans the
given input-output examples and heuristically
determines table joins and projection columns in
the result query. Then, it creates an
incomplete SQL query (called, a query skeleton) to
capture the basic structure of the result query.

\item \textbf{Query Completion.} \ourtool
uses a machine learning algorithm to infer a set of accurate
and expressive rules, which transforms the input
example into the output example. Then, it
searches for other missing parts in a query skeleton,
%possible aggregates and columns in
%the \CodeIn{ORDER BY} clause; 
and builds a list of candidate queries. 


\item \textbf{Candidate Ranking.} If multiple SQL
queries satisfy the given input-output examples,
\ourtool employs the Occam's razor principle to
rank more likely queries higher in the output.
\end{itemize}

Compared to previous approaches~\cite{Zloof:1975,
Tran:2009, DasSarma:2010, abs-1208-2013}, \ourtool has two notable features:

\begin{itemize}
\item \textbf{It is fully automated.} Besides
an example input and output pair,
\ourtool does not require users to provide
annotations or hints of any form. 
This distinguishes our work from competing techniques such as
specification-based query inference~\cite{Zloof:1975} and
query synthesis from imperative code~\cite{abs-1208-2013}.

\item \textbf{It supports a wide range of SQL queries.}
Similar approaches in the literature support
a small subset of the SQL language; and most of them
can only infer simple select-from-where
queries on a single table~\cite{Zloof:1975, DasSarma:2010, Tran:2009, DasSarma:2010, abs-1208-2013}. By contrast, 
\ourtool significantly enriches the supported SQL subset.
Besides supporting the standard select-from-where
queries, \ourtool also supports many advanced
SQL features, such as table joins,
aggregates (e.g., \CodeIn{MAX}, \CodeIn{MIN}, \CodeIn{SUM},
and \CodeIn{COUNT}), the \CodeIn{GROUP BY} clause,
the \CodeIn{ORDER BY} clause, and the \CodeIn{HAVING} clause.
%\item \textbf{It requires small input-output examples.}
\end{itemize}


%is usually the correct one. 

%Besides
%selecting a smaller one, we could also compute the likelihood
%of each query being correct based on some statistics, and then
%pick the most likely one.


%\subsection{Evaluation}

\vspace{1mm}
\noindent \textbf{\textit{Evaluation}}.
We evaluated \ourtool's generality and accuracy
in two aspects. First, we used \ourtool to solve
\exnum SQL exercises from a classic database textbook~\cite{cowbook}. 
We used textbook exercises because they
are often designed to cover a wide range of SQL features.
Some exercises are even designed on purpose to cover some less realistic,
corner cases in using SQL.
%the most important
%SQL features that an instructor wishes students to master,
Second, we evaluated \ourtool on \exnum SQL query related
questions collected from popular online help forums, and tested whether
\ourtool can synthesize correct SQL queries for them.

As a result, \ourtool successfully synthesized queries
for \solexnum out of \exnum textbook exercises and
all \pnum forum problems, within a very
small amount of time (\avgtime minute per exercise or problem, on average).
\ourtool's accuracy and speed make it an attractive
tool for end-users to use.% write SQL queries.

%\subsection{Contributions}

\vspace{1mm}
\noindent\textbf{\textit{Contributions.}}
This paper makes the following contributions:

\begin{itemize}
%\item \textbf{Problem.} To the best of our knowledge, we are the first
%to address the SQL query synthesis problem from examples across multiple
%tables.
%An approach to automatically synthesizing SQL
%queries from input-output examples (Section~\ref{sec:approach}).

\item \textbf{Technique.} We present a technique that automatically
synthesizes SQL queries from input-output examples
(Section~\ref{sec:approach}).

\item \textbf{Implementation.} We implemented our technique in a
tool, called \ourtool (Section~\ref{sec:implementation}). It is
available at: \url{http://sqlsynthesizer.googlecode.com}.

\item \textbf{Evaluation.} We applied \ourtool
to \exnum textbook exercises and \pnum 
forum questions.
The experimental results show that \ourtool is
useful in synthesizing SQL queries with
small examples (Section~\ref{sec:evaluation}).
\end{itemize}
