\subsection{Overview}
\label{sec:algorithm}

Figure~\ref{fig:workflow} illustrates \ourtool's workflow.
\ourtool consists of three steps: (1) the ``Skeleton Creation'' step (Section~\ref{sec:skeleton})
infers a partially-complete SQL query as a skeleton from the given
examples; (2) the ``Query Completion'' step (Section~\ref{sec:completion}) 
computes the missing parts in a query skeleton and outputs
a list of syntactically-valid query candidates that satisfy
the provided input-output examples; and (3) the ``Candidate Ranking'' step (Section~\ref{sec:ranking})
ranks all sythesized SQL query candidates with the more likely ones on the top. 
Users select the desirable SQL queries from the produced ranked query list.
If \ourtool produces SQL queries that satisfy the input and
output examples, but does not address the intention that the user wants;
\ourtool can be used interactively by asking users to provide more
informative examples and then refine the SQL queries.

Figure~\ref{fig:algorithm} sketches \ourtool's algorithm, which corresponds
to its three steps. Line 2 corresponds to the first ``Query Skeleton
Creation'' step. Lines 3 -- 13 correspond to the second ``Query Completion''
step, in which \ourtool searches for the query conditions (line 4), aggregate
functions (line 5), and order by columns (line 6) for each skeleton; and
then builds a list of syntactically-correct SQL queries (line 7) and
validates them on the examples (lines 8 -- 11).
ine 14 corresponds to the ``Query Ranking'' step.

%the result list (line 10). Finally, the query list is sorted by using
%the Occam's razor principle (line 14), and returned to the end-users.

\begin{figure}[t]

\textbf{Input}: example input table(s) $T_I$, example output table $T_O$\\

\vspace{-4mm}
\textbf{Output}: a ranked list of SQL queries\\
\vspace{1mm}
sythesizeSQLQueries({$V_{old}$, $V_{new}$, $T$})\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{queryList}$ $\leftarrow$ an empty list\\
\STATE $\mathit{skeletons}$ $\leftarrow$ createQuerySkeletons($\mathit{T_I}$, $\mathit{T_O}$)
\FOR{each $\mathit{skeleton}$ in $\mathit{skeletons}$}
\STATE $\mathit{conds}$ $\leftarrow$ inferConditions($\mathit{T_I}$, $\mathit{T_O}$, $\mathit{skeleton}$)
\STATE $\mathit{aggs}$ $\leftarrow$ searchForAggregates($\mathit{T_I}$, $\mathit{T_O}$, $\mathit{skeleton}$, $conds$)
\STATE $\mathit{columns}$ $\leftarrow$ searchForOrderBys($\mathit{T_O}$, $\mathit{skeleton}$, $\mathit{aggs}$)
\STATE $\mathit{queries}$ $\leftarrow$ buildQueries($\mathit{skeleton}$, $\mathit{conds}$, $\mathit{aggs}$, $\mathit{columns}$)
\FOR{each $\mathit{query}$ in $\mathit{queries}$}
\IF{validateOnDatabase($\mathit{query}$, $\mathit{T_I}$, $\mathit{T_O}$)}
\STATE $\mathit{queryList}$.add($\mathit{query}$)
\ENDIF
\ENDFOR
\ENDFOR
\STATE rankQueries($\mathit{queryList}$)
\RETURN $\mathit{queryList}$
\end{algorithmic}
\vspace{-3mm}
\caption{Algorithm for sythesizing SQL queries from input-output examples.}
 \label{fig:algorithm}
\end{figure}
