
\section{Related Work}
\label{sec:related}

This section discusses two categories
of closely-related work on reverse engineering SQL queries 
and automated program synthesis.


\subsection{Reverse Engineering SQL Queries}

Reverse engineering SQL queries is a well-known technique in the database
community~\cite{Zloof:1975, Tran:2009, DasSarma:2010} to
enhance a database system's usability. 
Zloof's pioneering work on \textit{Query by Example} (QBE)~\cite{Zloof:1975}
provided a high-level query language and a
form-based Graphical User Interface (GUI) for
writing database queries. To use the QBE system, 
users need to learn its own query language,
formulate a query with the language, and fill in
the appropriate skeleton tables on the GUI.
By contrast, \ourtool mitigates such learning curves
by only requiring users to provide some representative
examples to describe their query intentions

  %In other words, to derive a SQL query with the QBE system,
%end-users must learn a new query formulation language
%and explore its GUIs. These are the exactly
%two activities that may increase end-users' learning curve, and are avoided
%in \ourtool. \todo{exactly what we need to avoid.}



Tran et al.~\cite{Tran:2009} proposed a technique,
called \textit{Query by Output} (QBO), 
to find a set of semantically-equivalent SQL queries
to a given input query. QBO is related to but
significantly differs from \ourtool in two aspects.
First, QBO has a rather different goal and requires
different inputs : it takes as inputs a database,
an SQL query, and the query's output (on the database); and computes
one or more equivalent queries that produce the
same output on the input database.
Second, QBO can only infer simple select-project-join queries,
while excluding many useful SQL features, such as aggregates,
the \CodeIn{Having} clause, and the \CodeIn{Group by}
clause. As we demonstrated in in Section~\ref{sec:evaluation},
 queries inferred by QBO cannot be applied to many of the other
real-world cases.
QBO's key limitation stems from the fact that it
only considers existing tuple values
in the input tables as features, when learning
a set of classification rules as query conditions. 
By contrast, \ourtool remedies this limitation by enhancing
the existing tuple values with two kinds of
additional features (Section~\ref{sec:condition}).


Recently, Sarma et al.~\cite{DasSarma:2010} studied the \textit{View Definitions Problem} (VDP).
VDP aims to find the most
succinct and accurate view definition, when
the view query is restricted to a specific family of queries.
VDP can be solved as a special case in \ourtool where there is only one
input table and one output table. Furthermore, the main contribution
of Sarma et al's work is the complexity analysis of
three variants of the view definitions problem; there is no
tool implementation or empirical studies to evaluate
the proposed technique.

%Compared to \ourtool, there are three key differences:
%(1) VDP aims to infer a relation from a large representative
%example view, while \ourtool attempts to infer a SQL query from a
%set of few input-output examples \todo{revise below}
%(which is a critical usability aspect for end-users who lack adequate
%SQL experience). (2) the technique proposed by Sarma et al.~\cite{DasSarma:2010} does
%not consider join or projection
%operations and assumes the output view to be a strict subset of the input
%database with the same schema\todo{revise}, while our work eliminates these
%assumptions, and considers both join and projection operations.\todo{revise above}



%\todo{what is the limitation of non program sythesis, why
%sythensis would be useful.}

\subsection{Automated Program Synthesis }


Program synthesis~\cite{Gulwani:2010:DPS} is a useful
technique to create an executable program
in some underlying language from specifications that can range
from logical declarative specifications to examples or
demonstrations~\cite{Harris:2011, singh:2012, Gulwani:2011,
Kandel:2011, Fisher08Pads,Lau:2003:PDU, Lau:2000:VSA, Barbosa:2010:MLA, Arasu:2009:LST}.
It has been used recently for many applications
such as synthesis of efficient low-level code~\cite{Solar-Lezama:2005},
data structure manipulations~\cite{Fisher:2008},
geometry constructions~\cite{Gulwani:2011:SGC},
snippets of excel macros~\cite{Harris:2011},
relational data representations~\cite{Barbosa:2010:MLA, Arasu:2009:LST} and string
expressions~\cite{singh:2012, Gulwani:2011}.


The PADS~\cite{Fisher:2008} system takes a large sample
of unstructured data and infers a
format that describes the data. Related,
the Wrangler tool, developed in the HCI community,
provides a visual programming-by-demonstration
interface to table transformations for data cleaning~\cite{Kandel:2011}.
These two techniques, though well-suited for tasks
like text extraction, are inapplicable to
synthesizing  a database query, since they use completely
different abstractions than SQL and lack the support
for many database operations like table joining, aggregations, etc.
%For example, while text extraction and mass editing
%are quite valuable for data transformation, the above tools
%lack other needed operations such as table joinning,
%aggregation, and query condition inference.
%\todo{explain}


Harris and Gulwani described a system for learning excel
spreadsheet transformation macros from an example
input-output pair~\cite{Harris:2011}. Given one input table and one output
table, their system can infer an excel macro that filters,
duplicates, and/or reorganizes table cells to generate the output table.
\ourtool differs in multiple respects.
First, excel macros have significantly different
semantics than the SQL language.
An excel macro can express a variety of table transformation operations
(e.g., table re-shaping), but are not capable to formulate database queries.
Second, Harris and Gulwani's approach treats table cells
as atomic units, and thus has different expressiveness
than \ourtool. For instance, their technique can generate macros to
transform one table to another, but cannot join multiple
tables or group query results by certain table columns. 
%does not support queries
%involving conditions table joining, aggregation, or even column projection.
%\todo{examples}


%By contrast, \ourtool provides
%an interface based on examples, which is more
%friendly to end users. \todo{However, }


Some recent work proposed query recommendations systems to reduce
the obstacles to using relational databases~\cite{Howe:2011, Khoussainova:2010}. 
SQLShare~\cite{Howe:2011} is a cloud-based service that allows
users to upload their data and SQL queries. 
Each uploaded query is saved as a view, allowing other users
to compose and reuse. SnipSuggest~\cite{Khoussainova:2010} is a SQL autocompletion
system. As a user types a query, SnipSuggest mines existing query
logs to recommend relevant clauses or SQL snippets (e.g., the table
names for the \CodeIn{from} clause) based on the partial query that
the user has typed so far.
Compared to \ourtool, both SQLShare and SnipSuggest assume the
existence of a comprehensive query log (produced either
by the user herself or other users)
that contains valuable information.
%as a user articulates an increasingly larger fragment of a query.
However, such assumption often does not hold for
many database users in practice.
\ourtool eliminates this assumption and infers 
SQL queries by using user-provided examples.


Cheung et al~\cite{abs-1208-2013} presented a technique to infer SQL
queries from imperative code. Their technique identifies
fragments of application logic (written in an imperative language
like Java) that can be pushed into SQL queries. 
Compared to \ourtool, their work is designed for developers
to improve a database application's performance,
rather than helping non-expert end-users
write correct SQL queries from scratch. 
If an end-user wishes to use their technique to 
synthesize a SQL query, she must write a snippet of
imperative code to describe the query task.
Comparing to providing example input
and output as required by \ourtool,
writing correct imperative code can be too challenging
for a typical end-user, and thus would
substantially degrade the technique's usability in practice.


%also cite this~\cite{Cheung:2012:UPS}, combining machine learning with program synthesis.
